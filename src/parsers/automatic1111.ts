import { Parser, ReplacementRules, popKeys } from './parser';
import { Generators, createPromptInfo, createSampler, createModel, createPrompt, PromptInfo } from '../data';
import { ParserError } from '../exceptions';

const SAMPLER_PARAMS = ['Sampler', 'CFG scale', 'Seed', 'Steps', 'ENSD', 'Schedule type', 'Denoising strength', 'Clip skip'];

const REPLACEMENT_RULES: ReplacementRules = [
  ['Schedule type', 'scheduler'],
  ['CFG scale', 'cfg_scale'],
  ['Seed', 'seed'],
  ['Steps', 'steps'],
  ['Denoising strength', 'denoising_strength'],
  ['Clip skip', 'clip_skip']
];

/**
 * Parser for images generated by AUTOMATIC1111's stable-diffusion-webui or similar
 */
export class AUTOMATIC1111Parser extends Parser {
  public readonly generator = Generators.AUTOMATIC1111;

  async parse(parameters: Record<string, any>): Promise<PromptInfo> {
    let lines: string[];
    
    try {
      if (!parameters.parameters || typeof parameters.parameters !== 'string') {
        throw new Error('parameters field is missing or not a string');
      }
      lines = parameters.parameters.split('\n');
    } catch (error) {
      throw new ParserError(`Error reading parameter string: ${error}`);
    }

    try {
      const { infoIndex, samplerInfo, metadata } = getSamplerInfo(lines);
      const prompts = lines.slice(0, infoIndex).join('\n').split('Negative prompt:');
      const prompt = prompts[0]?.trim() || '';
      const negativePrompt = prompts[1]?.trim() || '';

      const samplerParams = Object.fromEntries(popKeys(SAMPLER_PARAMS, samplerInfo));
      const samplerName = samplerParams.Sampler || 'unknown';
      delete samplerParams.Sampler;
      
      const normalizedParams = this.normalizeParameters(samplerParams, REPLACEMENT_RULES);
      
      const modelName = metadata.Model;
      const modelHash = metadata['Model hash'];
      delete metadata.Model;
      delete metadata['Model hash'];

      const model = (modelName || modelHash) ? createModel({ name: modelName, hash: modelHash }) : undefined;
      
      const promptList = prompt ? [createPrompt(prompt)] : [];
      const negativePromptList = negativePrompt ? [createPrompt(negativePrompt)] : [];
      
      const sampler = createSampler(samplerName, normalizedParams, {
        model,
        prompts: promptList,
        negativePrompts: negativePromptList
      });

      return createPromptInfo(this.generator, [sampler], metadata, parameters);
    } catch (error) {
      // Fallback: if no sampler info found, treat entire string as prompt
      const fullText = lines.join('\n');
      const prompts = fullText.split('Negative prompt:');
      const prompt = prompts[0]?.trim() || '';
      const negativePrompt = prompts[1]?.trim() || '';
      
      const promptList = prompt ? [createPrompt(prompt)] : [];
      const negativePromptList = negativePrompt ? [createPrompt(negativePrompt)] : [];
      
      const sampler = createSampler('unknown', {}, {
        prompts: promptList,
        negativePrompts: negativePromptList
      });

      return createPromptInfo(this.generator, [sampler], {}, parameters);
    }
  }
}

/**
 * Extract sampler information from parameter lines
 */
function getSamplerInfo(lines: string[]): { infoIndex: number; samplerInfo: Record<string, any>; metadata: Record<string, any> } {
  for (let index = lines.length - 1; index >= 0; index--) {
    const line = lines[index];
    const metadata = extractMetadata(line);
    const samplerInfo = Object.fromEntries(popKeys(SAMPLER_PARAMS, { ...metadata }));
    
    if (Object.keys(samplerInfo).length >= 3) {
      return { infoIndex: index, samplerInfo, metadata };
    }
  }

  throw new ParserError('No sampler information found');
}

/**
 * Extract metadata from a parameter line
 */
function extractMetadata(line: string): Record<string, any> {
  const metadata: Record<string, any> = {};

  // Try to extract hashes
  const hashMatch = line.match(/(?:,\s*)?Hashes:\s*(\{[^}]*\})\s*/);
  if (hashMatch) {
    try {
      metadata.Hashes = JSON.parse(hashMatch[1]);
      line = line.substring(0, hashMatch.index) + line.substring(hashMatch.index! + hashMatch[0].length);
    } catch (error) {
      // Ignore JSON parse errors
    }
  }

  // Extract key-value pairs
  for (const item of line.split(',')) {
    try {
      const colonIndex = item.indexOf(':');
      if (colonIndex > 0) {
        const key = item.substring(0, colonIndex).trim();
        const value = item.substring(colonIndex + 1).trim();
        metadata[key] = value;
      }
    } catch (error) {
      // Ignore parsing errors for individual items
    }
  }

  return metadata;
}
