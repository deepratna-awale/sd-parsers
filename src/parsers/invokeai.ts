import { Parser } from './parser';
import { Generators, createPromptInfo, createSampler, createPrompt, PromptInfo } from '../data';
import { ParserError } from '../exceptions';

/**
 * Parser for images generated by InvokeAI
 */
export class InvokeAIParser extends Parser {
  public readonly generator = Generators.INVOKEAI;

  async parse(metadata: Record<string, any>): Promise<PromptInfo> {
    // Try different InvokeAI metadata formats
    
    // Format 1: sd-metadata
    if (metadata['sd-metadata']) {
      return this.parseSdMetadata(metadata['sd-metadata']);
    }
    
    // Format 2: Dream format (legacy)
    if (metadata.Dream) {
      return this.parseDream(metadata.Dream);
    }
    
    // Format 3: invokeai_metadata
    if (metadata.invokeai_metadata || metadata.invokeai_graph) {
      return this.parseInvokeAiMeta(metadata);
    }

    throw new ParserError('No supported InvokeAI metadata format found');
  }

  private parseSdMetadata(sdMetadata: any): PromptInfo {
    try {
      const data = typeof sdMetadata === 'string' ? JSON.parse(sdMetadata) : sdMetadata;
      
      const samplerName = data.sampler_name || data.image?.sampler || data.sampler || 'unknown';
      const parameters: Record<string, any> = {};
      
      // Get parameters from root or image object
      const imageData = data.image || data;
      
      if (imageData.cfg_scale !== undefined) parameters.cfg_scale = imageData.cfg_scale;
      if (imageData.steps !== undefined) parameters.steps = imageData.steps;
      if (imageData.seed !== undefined) parameters.seed = imageData.seed;
      if (imageData.width !== undefined) parameters.width = imageData.width;
      if (imageData.height !== undefined) parameters.height = imageData.height;

      const prompts = (data.prompt || imageData.prompt) ? [createPrompt(data.prompt || imageData.prompt)] : [];
      const negativePrompts = (data.negative_prompt || imageData.negative_prompt) ? [createPrompt(data.negative_prompt || imageData.negative_prompt)] : [];

      const sampler = createSampler(samplerName, parameters, {
        prompts,
        negativePrompts
      });

      return createPromptInfo(this.generator, [sampler], data, { 'sd-metadata': sdMetadata });
    } catch (error) {
      throw new ParserError(`Error parsing sd-metadata: ${error}`);
    }
  }

  private parseDream(dreamParam: string): PromptInfo {
    try {
      // Parse legacy Dream format: "prompt" -s steps -S seed -C cfg_scale etc.
      // or prompt -s steps -S seed -C cfg_scale etc. (without quotes)
      let match = dreamParam.match(/^"(.*?)"(.*)$/);
      let prompt: string;
      let args: string;
      
      if (match) {
        [, prompt, args] = match;
      } else {
        // Try without quotes - split on first occurrence of " -"
        const dashIndex = dreamParam.indexOf(' -');
        if (dashIndex !== -1) {
          prompt = dreamParam.substring(0, dashIndex);
          args = dreamParam.substring(dashIndex);
        } else {
          // No arguments, entire string is the prompt
          prompt = dreamParam;
          args = '';
        }
      }

      const metadata: Record<string, any> = {};
      const parameters: Record<string, any> = {};

      // Parse arguments - look for patterns like "-s 20"
      if (args) {
        const argMatches = args.matchAll(/-(\w+)\s+([^\s-]+)/g);
        for (const argMatch of argMatches) {
          const [, key, value] = argMatch;
          
          switch (key) {
            case 'A':
              parameters.sampler = value;
              break;
            case 'C':
              parameters.cfg_scale = value;
              break;
            case 'H':
              parameters.height = value;
              break;
            case 's':
              parameters.steps = value;
              break;
            case 'S':
              parameters.seed = value;
              break;
            case 'W':
              parameters.width = value;
              break;
            default:
              metadata[key] = value;
          }
        }
      }

      const samplerName = parameters.sampler || 'unknown';
      delete parameters.sampler;

      const prompts = prompt ? [createPrompt(prompt)] : [];
      
      const sampler = createSampler(samplerName, parameters, {
        prompts
      });

      return createPromptInfo(this.generator, [sampler], metadata, { Dream: dreamParam });
    } catch (error) {
      throw new ParserError(`Error parsing Dream format: ${error}`);
    }
  }

  private parseInvokeAiMeta(metadata: Record<string, any>): PromptInfo {
    try {
      let data: any = {};
      
      if (metadata.invokeai_metadata) {
        data = typeof metadata.invokeai_metadata === 'string' 
          ? JSON.parse(metadata.invokeai_metadata) 
          : metadata.invokeai_metadata;
      }

      const samplerName = data.sampler_name || data.scheduler || 'unknown';
      const parameters: Record<string, any> = {};
      
      if (data.cfg_scale !== undefined) parameters.cfg_scale = data.cfg_scale;
      if (data.steps !== undefined) parameters.steps = data.steps;
      if (data.seed !== undefined) parameters.seed = data.seed;
      if (data.width !== undefined) parameters.width = data.width;
      if (data.height !== undefined) parameters.height = data.height;

      const prompts = data.positive_prompt || data.prompt ? 
        [createPrompt(data.positive_prompt || data.prompt)] : [];
      const negativePrompts = data.negative_prompt ? 
        [createPrompt(data.negative_prompt)] : [];

      const sampler = createSampler(samplerName, parameters, {
        prompts,
        negativePrompts
      });

      return createPromptInfo(this.generator, [sampler], data, metadata);
    } catch (error) {
      throw new ParserError(`Error parsing InvokeAI metadata: ${error}`);
    }
  }
}
