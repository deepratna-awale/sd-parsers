"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvokeAIParser = void 0;
const parser_1 = require("./parser");
const data_1 = require("../data");
const exceptions_1 = require("../exceptions");
/**
 * Parser for images generated by InvokeAI
 */
class InvokeAIParser extends parser_1.Parser {
    constructor() {
        super(...arguments);
        this.generator = data_1.Generators.INVOKEAI;
    }
    async parse(metadata) {
        // Try different InvokeAI metadata formats
        // Format 1: sd-metadata
        if (metadata['sd-metadata']) {
            return this.parseSdMetadata(metadata['sd-metadata']);
        }
        // Format 2: Dream format (legacy)
        if (metadata.Dream) {
            return this.parseDream(metadata.Dream);
        }
        // Format 3: invokeai_metadata
        if (metadata.invokeai_metadata || metadata.invokeai_graph) {
            return this.parseInvokeAiMeta(metadata);
        }
        throw new exceptions_1.ParserError('No supported InvokeAI metadata format found');
    }
    parseSdMetadata(sdMetadata) {
        try {
            const data = typeof sdMetadata === 'string' ? JSON.parse(sdMetadata) : sdMetadata;
            const samplerName = data.sampler_name || data.image?.sampler || data.sampler || 'unknown';
            const parameters = {};
            // Get parameters from root or image object
            const imageData = data.image || data;
            if (imageData.cfg_scale !== undefined)
                parameters.cfg_scale = imageData.cfg_scale;
            if (imageData.steps !== undefined)
                parameters.steps = imageData.steps;
            if (imageData.seed !== undefined)
                parameters.seed = imageData.seed;
            if (imageData.width !== undefined)
                parameters.width = imageData.width;
            if (imageData.height !== undefined)
                parameters.height = imageData.height;
            const prompts = (data.prompt || imageData.prompt) ? [(0, data_1.createPrompt)(data.prompt || imageData.prompt)] : [];
            const negativePrompts = (data.negative_prompt || imageData.negative_prompt) ? [(0, data_1.createPrompt)(data.negative_prompt || imageData.negative_prompt)] : [];
            const sampler = (0, data_1.createSampler)(samplerName, parameters, {
                prompts,
                negativePrompts
            });
            return (0, data_1.createPromptInfo)(this.generator, [sampler], data, { 'sd-metadata': sdMetadata });
        }
        catch (error) {
            throw new exceptions_1.ParserError(`Error parsing sd-metadata: ${error}`);
        }
    }
    parseDream(dreamParam) {
        try {
            // Parse legacy Dream format: "prompt" -s steps -S seed -C cfg_scale etc.
            // or prompt -s steps -S seed -C cfg_scale etc. (without quotes)
            let match = dreamParam.match(/^"(.*?)"(.*)$/);
            let prompt;
            let args;
            if (match) {
                [, prompt, args] = match;
            }
            else {
                // Try without quotes - split on first occurrence of " -"
                const dashIndex = dreamParam.indexOf(' -');
                if (dashIndex !== -1) {
                    prompt = dreamParam.substring(0, dashIndex);
                    args = dreamParam.substring(dashIndex);
                }
                else {
                    // No arguments, entire string is the prompt
                    prompt = dreamParam;
                    args = '';
                }
            }
            const metadata = {};
            const parameters = {};
            // Parse arguments - look for patterns like "-s 20"
            if (args) {
                const argMatches = args.matchAll(/-(\w+)\s+([^\s-]+)/g);
                for (const argMatch of argMatches) {
                    const [, key, value] = argMatch;
                    switch (key) {
                        case 'A':
                            parameters.sampler = value;
                            break;
                        case 'C':
                            parameters.cfg_scale = value;
                            break;
                        case 'H':
                            parameters.height = value;
                            break;
                        case 's':
                            parameters.steps = value;
                            break;
                        case 'S':
                            parameters.seed = value;
                            break;
                        case 'W':
                            parameters.width = value;
                            break;
                        default:
                            metadata[key] = value;
                    }
                }
            }
            const samplerName = parameters.sampler || 'unknown';
            delete parameters.sampler;
            const prompts = prompt ? [(0, data_1.createPrompt)(prompt)] : [];
            const sampler = (0, data_1.createSampler)(samplerName, parameters, {
                prompts
            });
            return (0, data_1.createPromptInfo)(this.generator, [sampler], metadata, { Dream: dreamParam });
        }
        catch (error) {
            throw new exceptions_1.ParserError(`Error parsing Dream format: ${error}`);
        }
    }
    parseInvokeAiMeta(metadata) {
        try {
            let data = {};
            if (metadata.invokeai_metadata) {
                data = typeof metadata.invokeai_metadata === 'string'
                    ? JSON.parse(metadata.invokeai_metadata)
                    : metadata.invokeai_metadata;
            }
            const samplerName = data.sampler_name || data.scheduler || 'unknown';
            const parameters = {};
            if (data.cfg_scale !== undefined)
                parameters.cfg_scale = data.cfg_scale;
            if (data.steps !== undefined)
                parameters.steps = data.steps;
            if (data.seed !== undefined)
                parameters.seed = data.seed;
            if (data.width !== undefined)
                parameters.width = data.width;
            if (data.height !== undefined)
                parameters.height = data.height;
            const prompts = data.positive_prompt || data.prompt ?
                [(0, data_1.createPrompt)(data.positive_prompt || data.prompt)] : [];
            const negativePrompts = data.negative_prompt ?
                [(0, data_1.createPrompt)(data.negative_prompt)] : [];
            const sampler = (0, data_1.createSampler)(samplerName, parameters, {
                prompts,
                negativePrompts
            });
            return (0, data_1.createPromptInfo)(this.generator, [sampler], data, metadata);
        }
        catch (error) {
            throw new exceptions_1.ParserError(`Error parsing InvokeAI metadata: ${error}`);
        }
    }
}
exports.InvokeAIParser = InvokeAIParser;
//# sourceMappingURL=invokeai.js.map